{"version":3,"sources":["RoomClient.tsx","App.tsx","index.tsx"],"names":["RoomClient","constructor","roomId","name","socket","localStream","this","io","on","console","log","joinRoom","navigator","mediaDevices","getUserMedia","video","audio","videoElement","document","createElement","srcObject","autoplay","body","appendChild","emit","room_id","peers","error","App","setRoomId","useState","setName","roomClient","setRoomClient","_jsxs","children","_jsx","type","placeholder","value","onChange","e","target","onClick","handleJoin","client","ReactDOM","render","React","StrictMode","getElementById"],"mappings":"2LA4CeA,MA1Cf,MAMEC,YAAYC,EAAgBC,GAAe,KAL3CC,YAAM,OACNC,YAAkC,KAAK,KACvCH,YAAM,OACNC,UAAI,EAGFG,KAAKJ,OAASA,EACdI,KAAKH,KAAOA,EACZG,KAAKF,OAASG,YAAG,0BAEjBD,KAAKF,OAAOI,GAAG,WAAW,KACxBC,QAAQC,IAAI,uBACZJ,KAAKK,UAAU,IAGjBL,KAAKF,OAAOI,GAAG,cAAc,KAC3BC,QAAQC,IAAI,2BAA2B,GAE3C,CAEA,cAAMC,GACJ,IACEL,KAAKD,kBAAoBO,UAAUC,aAAaC,aAAa,CAC3DC,OAAO,EACPC,OAAO,IAGT,MAAMC,EAAeC,SAASC,cAAc,SAC5CF,EAAaG,UAAYd,KAAKD,YAC9BY,EAAaI,UAAW,EACxBH,SAASI,KAAKC,YAAYN,GAE1BX,KAAKF,OAAOoB,KAAK,WAAY,CAAEC,QAASnB,KAAKJ,OAAQC,KAAMG,KAAKH,OAASuB,IACvEjB,QAAQC,IAAI,cAAegB,EAAM,GAErC,CAAE,MAAOC,GACPlB,QAAQkB,MAAM,iCAAkCA,EAClD,CACF,G,OCNaC,MAhCOA,KACpB,MAAO1B,EAAQ2B,GAAaC,mBAAS,KAC9B3B,EAAM4B,GAAWD,mBAAS,KAC1BE,EAAYC,GAAiBH,mBAA4B,MAShE,OACEI,eAAA,OAAAC,SAAA,CACEC,cAAA,SACEC,KAAK,OACLC,YAAY,UACZC,MAAOrC,EACPsC,SAAWC,GAAMZ,EAAUY,EAAEC,OAAOH,SAEtCH,cAAA,SACEC,KAAK,OACLC,YAAY,YACZC,MAAOpC,EACPqC,SAAWC,GAAMV,EAAQU,EAAEC,OAAOH,SAEpCH,cAAA,UAAQO,QArBOC,KACjB,GAAI1C,GAAUC,EAAM,CAClB,MAAM0C,EAAS,IAAI7C,EAAWE,EAAQC,GACtC8B,EAAcY,EAChB,GAiB8BV,SAAC,cAC5BH,GAAcI,cAAA,OAAAD,SAAK,8BAChB,EC3BVW,IAASC,OACPX,cAACY,IAAMC,WAAU,CAAAd,SACfC,cAACR,EAAG,MAENV,SAASgC,eAAe,Q","file":"static/js/main.d45acae4.chunk.js","sourcesContent":["import { io, Socket } from 'socket.io-client';\n\nclass RoomClient {\n  socket: Socket;\n  localStream: MediaStream | null = null;\n  roomId: string;\n  name: string;\n\n  constructor(roomId: string, name: string) {\n    this.roomId = roomId;\n    this.name = name;\n    this.socket = io('https://localhost:3016'); // Alterado para uso direto de `io`\n\n    this.socket.on('connect', () => {\n      console.log('Connected to server');\n      this.joinRoom();\n    });\n\n    this.socket.on('disconnect', () => {\n      console.log('Disconnected from server');\n    });\n  }\n\n  async joinRoom() {\n    try {\n      this.localStream = await navigator.mediaDevices.getUserMedia({\n        video: true,\n        audio: true\n      });\n\n      const videoElement = document.createElement('video');\n      videoElement.srcObject = this.localStream;\n      videoElement.autoplay = true;\n      document.body.appendChild(videoElement);\n\n      this.socket.emit('joinRoom', { room_id: this.roomId, name: this.name }, (peers: any) => {\n        console.log('Joined room', peers);\n      });\n    } catch (error) {\n      console.error('Error accessing media devices.', error);\n    }\n  }\n}\n\nexport default RoomClient;\n\n\n\n\n\n// const mediaType = {\n//   audio: 'audioType',\n//   video: 'videoType',\n//   screen: 'screenType'\n// }\n// const _EVENTS = {\n//   exitRoom: 'exitRoom',\n//   openRoom: 'openRoom',\n//   startVideo: 'startVideo',\n//   stopVideo: 'stopVideo',\n//   startAudio: 'startAudio',\n//   stopAudio: 'stopAudio',\n//   startScreen: 'startScreen',\n//   stopScreen: 'stopScreen'\n// }\n\n// class RoomClient {\n//   constructor(localMediaEl, remoteVideoEl, remoteAudioEl, mediasoupClient, socket, room_id, name, successCallback) {\n//     this.name = name\n//     this.localMediaEl = localMediaEl\n//     this.remoteVideoEl = remoteVideoEl\n//     this.remoteAudioEl = remoteAudioEl\n//     this.mediasoupClient = mediasoupClient\n\n//     this.socket = socket\n//     this.producerTransport = null\n//     this.consumerTransport = null\n//     this.device = null\n//     this.room_id = room_id\n\n//     this.isVideoOnFullScreen = false\n//     this.isDevicesVisible = false\n\n//     this.consumers = new Map()\n//     this.producers = new Map()\n\n//     console.log('Mediasoup client', mediasoupClient)\n\n//     /**\n//      * map that contains a mediatype as key and producer_id as value\n//      */\n//     this.producerLabel = new Map()\n\n//     this._isOpen = false\n//     this.eventListeners = new Map()\n\n//     Object.keys(_EVENTS).forEach(\n//       function (evt) {\n//         this.eventListeners.set(evt, [])\n//       }.bind(this)\n//     )\n\n//     this.createRoom(room_id).then(\n//       async function () {\n//         await this.join(name, room_id)\n//         this.initSockets()\n//         this._isOpen = true\n//         successCallback()\n//       }.bind(this)\n//     )\n//   }\n\n//   ////////// INIT /////////\n\n//   async createRoom(room_id) {\n//     await this.socket\n//       .request('createRoom', {\n//         room_id\n//       })\n//       .catch((err) => {\n//         console.log('Create room error:', err)\n//       })\n//   }\n\n//   async join(name, room_id) {\n//     socket\n//       .request('join', {\n//         name,\n//         room_id\n//       })\n//       .then(\n//         async function (e) {\n//           console.log('Joined to room', e)\n//           const data = await this.socket.request('getRouterRtpCapabilities')\n//           let device = await this.loadDevice(data)\n//           this.device = device\n//           await this.initTransports(device)\n//           this.socket.emit('getProducers')\n//         }.bind(this)\n//       )\n//       .catch((err) => {\n//         console.log('Join error:', err)\n//       })\n//   }\n\n//   async loadDevice(routerRtpCapabilities) {\n//     let device\n//     try {\n//       device = new this.mediasoupClient.Device()\n//     } catch (error) {\n//       if (error.name === 'UnsupportedError') {\n//         console.error('Browser not supported')\n//         alert('Browser not supported')\n//       }\n//       console.error(error)\n//     }\n//     await device.load({\n//       routerRtpCapabilities\n//     })\n//     return device\n//   }\n\n//   async initTransports(device) {\n//     // init producerTransport\n//     {\n//       const data = await this.socket.request('createWebRtcTransport', {\n//         forceTcp: false,\n//         rtpCapabilities: device.rtpCapabilities\n//       })\n\n//       if (data.error) {\n//         console.error(data.error)\n//         return\n//       }\n\n//       this.producerTransport = device.createSendTransport(data)\n\n//       this.producerTransport.on(\n//         'connect',\n//         async function ({ dtlsParameters }, callback, errback) {\n//           this.socket\n//             .request('connectTransport', {\n//               dtlsParameters,\n//               transport_id: data.id\n//             })\n//             .then(callback)\n//             .catch(errback)\n//         }.bind(this)\n//       )\n\n//       this.producerTransport.on(\n//         'produce',\n//         async function ({ kind, rtpParameters }, callback, errback) {\n//           try {\n//             const { producer_id } = await this.socket.request('produce', {\n//               producerTransportId: this.producerTransport.id,\n//               kind,\n//               rtpParameters\n//             })\n//             callback({\n//               id: producer_id\n//             })\n//           } catch (err) {\n//             errback(err)\n//           }\n//         }.bind(this)\n//       )\n\n//       this.producerTransport.on(\n//         'connectionstatechange',\n//         function (state) {\n//           switch (state) {\n//             case 'connecting':\n//               break\n\n//             case 'connected':\n//               //localVideo.srcObject = stream\n//               break\n\n//             case 'failed':\n//               this.producerTransport.close()\n//               break\n\n//             default:\n//               break\n//           }\n//         }.bind(this)\n//       )\n//     }\n\n//     // init consumerTransport\n//     {\n//       const data = await this.socket.request('createWebRtcTransport', {\n//         forceTcp: false\n//       })\n\n//       if (data.error) {\n//         console.error(data.error)\n//         return\n//       }\n\n//       // only one needed\n//       this.consumerTransport = device.createRecvTransport(data)\n//       this.consumerTransport.on(\n//         'connect',\n//         function ({ dtlsParameters }, callback, errback) {\n//           this.socket\n//             .request('connectTransport', {\n//               transport_id: this.consumerTransport.id,\n//               dtlsParameters\n//             })\n//             .then(callback)\n//             .catch(errback)\n//         }.bind(this)\n//       )\n\n//       this.consumerTransport.on(\n//         'connectionstatechange',\n//         async function (state) {\n//           switch (state) {\n//             case 'connecting':\n//               break\n\n//             case 'connected':\n//               //remoteVideo.srcObject = await stream;\n//               //await socket.request('resume');\n//               break\n\n//             case 'failed':\n//               this.consumerTransport.close()\n//               break\n\n//             default:\n//               break\n//           }\n//         }.bind(this)\n//       )\n//     }\n//   }\n\n//   initSockets() {\n//     this.socket.on(\n//       'consumerClosed',\n//       function ({ consumer_id }) {\n//         console.log('Closing consumer:', consumer_id)\n//         this.removeConsumer(consumer_id)\n//       }.bind(this)\n//     )\n\n//     /**\n//      * data: [ {\n//      *  producer_id:\n//      *  producer_socket_id:\n//      * }]\n//      */\n//     this.socket.on(\n//       'newProducers',\n//       async function (data) {\n//         console.log('New producers', data)\n//         for (let { producer_id } of data) {\n//           await this.consume(producer_id)\n//         }\n//       }.bind(this)\n//     )\n\n//     this.socket.on(\n//       'disconnect',\n//       function () {\n//         this.exit(true)\n//       }.bind(this)\n//     )\n//   }\n\n//   //////// MAIN FUNCTIONS /////////////\n\n//   async produce(type, deviceId = null) {\n//     let mediaConstraints = {}\n//     let audio = false\n//     let screen = false\n//     switch (type) {\n//       case mediaType.audio:\n//         mediaConstraints = {\n//           audio: {\n//             deviceId: deviceId\n//           },\n//           video: false\n//         }\n//         audio = true\n//         break\n//       case mediaType.video:\n//         mediaConstraints = {\n//           audio: false,\n//           video: {\n//             width: {\n//               min: 640,\n//               ideal: 1920\n//             },\n//             height: {\n//               min: 400,\n//               ideal: 1080\n//             },\n//             deviceId: deviceId\n//             /*aspectRatio: {\n//                             ideal: 1.7777777778\n//                         }*/\n//           }\n//         }\n//         break\n//       case mediaType.screen:\n//         mediaConstraints = false\n//         screen = true\n//         break\n//       default:\n//         return\n//     }\n//     if (!this.device.canProduce('video') && !audio) {\n//       console.error('Cannot produce video')\n//       return\n//     }\n//     if (this.producerLabel.has(type)) {\n//       console.log('Producer already exists for this type ' + type)\n//       return\n//     }\n//     console.log('Mediacontraints:', mediaConstraints)\n//     let stream\n//     try {\n//       stream = screen\n//         ? await navigator.mediaDevices.getDisplayMedia()\n//         : await navigator.mediaDevices.getUserMedia(mediaConstraints)\n//       console.log(navigator.mediaDevices.getSupportedConstraints())\n\n//       const track = audio ? stream.getAudioTracks()[0] : stream.getVideoTracks()[0]\n//       const params = {\n//         track\n//       }\n//       if (!audio && !screen) {\n//         params.encodings = [\n//           {\n//             rid: 'r0',\n//             maxBitrate: 100000,\n//             //scaleResolutionDownBy: 10.0,\n//             scalabilityMode: 'S1T3'\n//           },\n//           {\n//             rid: 'r1',\n//             maxBitrate: 300000,\n//             scalabilityMode: 'S1T3'\n//           },\n//           {\n//             rid: 'r2',\n//             maxBitrate: 900000,\n//             scalabilityMode: 'S1T3'\n//           }\n//         ]\n//         params.codecOptions = {\n//           videoGoogleStartBitrate: 1000\n//         }\n//       }\n//       producer = await this.producerTransport.produce(params)\n\n//       console.log('Producer', producer)\n\n//       this.producers.set(producer.id, producer)\n\n//       let elem\n//       if (!audio) {\n//         elem = document.createElement('video')\n//         elem.srcObject = stream\n//         elem.id = producer.id\n//         elem.playsinline = false\n//         elem.autoplay = true\n//         elem.className = 'vid'\n//         this.localMediaEl.appendChild(elem)\n//         this.handleFS(elem.id)\n//       }\n\n//       producer.on('trackended', () => {\n//         this.closeProducer(type)\n//       })\n\n//       producer.on('transportclose', () => {\n//         console.log('Producer transport close')\n//         if (!audio) {\n//           elem.srcObject.getTracks().forEach(function (track) {\n//             track.stop()\n//           })\n//           elem.parentNode.removeChild(elem)\n//         }\n//         this.producers.delete(producer.id)\n//       })\n\n//       producer.on('close', () => {\n//         console.log('Closing producer')\n//         if (!audio) {\n//           elem.srcObject.getTracks().forEach(function (track) {\n//             track.stop()\n//           })\n//           elem.parentNode.removeChild(elem)\n//         }\n//         this.producers.delete(producer.id)\n//       })\n\n//       this.producerLabel.set(type, producer.id)\n\n//       switch (type) {\n//         case mediaType.audio:\n//           this.event(_EVENTS.startAudio)\n//           break\n//         case mediaType.video:\n//           this.event(_EVENTS.startVideo)\n//           break\n//         case mediaType.screen:\n//           this.event(_EVENTS.startScreen)\n//           break\n//         default:\n//           return\n//       }\n//     } catch (err) {\n//       console.log('Produce error:', err)\n//     }\n//   }\n\n//   async consume(producer_id) {\n//     //let info = await this.roomInfo()\n\n//     this.getConsumeStream(producer_id).then(\n//       function ({ consumer, stream, kind }) {\n//         this.consumers.set(consumer.id, consumer)\n\n//         let elem\n//         if (kind === 'video') {\n//           elem = document.createElement('video')\n//           elem.srcObject = stream\n//           elem.id = consumer.id\n//           elem.playsinline = false\n//           elem.autoplay = true\n//           elem.className = 'vid'\n//           this.remoteVideoEl.appendChild(elem)\n//           this.handleFS(elem.id)\n//         } else {\n//           elem = document.createElement('audio')\n//           elem.srcObject = stream\n//           elem.id = consumer.id\n//           elem.playsinline = false\n//           elem.autoplay = true\n//           this.remoteAudioEl.appendChild(elem)\n//         }\n\n//         consumer.on(\n//           'trackended',\n//           function () {\n//             this.removeConsumer(consumer.id)\n//           }.bind(this)\n//         )\n\n//         consumer.on(\n//           'transportclose',\n//           function () {\n//             this.removeConsumer(consumer.id)\n//           }.bind(this)\n//         )\n//       }.bind(this)\n//     )\n//   }\n\n//   async getConsumeStream(producerId) {\n//     const { rtpCapabilities } = this.device\n//     const data = await this.socket.request('consume', {\n//       rtpCapabilities,\n//       consumerTransportId: this.consumerTransport.id, // might be\n//       producerId\n//     })\n//     const { id, kind, rtpParameters } = data\n\n//     let codecOptions = {}\n//     const consumer = await this.consumerTransport.consume({\n//       id,\n//       producerId,\n//       kind,\n//       rtpParameters,\n//       codecOptions\n//     })\n\n//     const stream = new MediaStream()\n//     stream.addTrack(consumer.track)\n\n//     return {\n//       consumer,\n//       stream,\n//       kind\n//     }\n//   }\n\n//   closeProducer(type) {\n//     if (!this.producerLabel.has(type)) {\n//       console.log('There is no producer for this type ' + type)\n//       return\n//     }\n\n//     let producer_id = this.producerLabel.get(type)\n//     console.log('Close producer', producer_id)\n\n//     this.socket.emit('producerClosed', {\n//       producer_id\n//     })\n\n//     this.producers.get(producer_id).close()\n//     this.producers.delete(producer_id)\n//     this.producerLabel.delete(type)\n\n//     if (type !== mediaType.audio) {\n//       let elem = document.getElementById(producer_id)\n//       elem.srcObject.getTracks().forEach(function (track) {\n//         track.stop()\n//       })\n//       elem.parentNode.removeChild(elem)\n//     }\n\n//     switch (type) {\n//       case mediaType.audio:\n//         this.event(_EVENTS.stopAudio)\n//         break\n//       case mediaType.video:\n//         this.event(_EVENTS.stopVideo)\n//         break\n//       case mediaType.screen:\n//         this.event(_EVENTS.stopScreen)\n//         break\n//       default:\n//         return\n//     }\n//   }\n\n//   pauseProducer(type) {\n//     if (!this.producerLabel.has(type)) {\n//       console.log('There is no producer for this type ' + type)\n//       return\n//     }\n\n//     let producer_id = this.producerLabel.get(type)\n//     this.producers.get(producer_id).pause()\n//   }\n\n//   resumeProducer(type) {\n//     if (!this.producerLabel.has(type)) {\n//       console.log('There is no producer for this type ' + type)\n//       return\n//     }\n\n//     let producer_id = this.producerLabel.get(type)\n//     this.producers.get(producer_id).resume()\n//   }\n\n//   removeConsumer(consumer_id) {\n//     let elem = document.getElementById(consumer_id)\n//     elem.srcObject.getTracks().forEach(function (track) {\n//       track.stop()\n//     })\n//     elem.parentNode.removeChild(elem)\n\n//     this.consumers.delete(consumer_id)\n//   }\n\n//   exit(offline = false) {\n//     let clean = function () {\n//       this._isOpen = false\n//       this.consumerTransport.close()\n//       this.producerTransport.close()\n//       this.socket.off('disconnect')\n//       this.socket.off('newProducers')\n//       this.socket.off('consumerClosed')\n//     }.bind(this)\n\n//     if (!offline) {\n//       this.socket\n//         .request('exitRoom')\n//         .then((e) => console.log(e))\n//         .catch((e) => console.warn(e))\n//         .finally(\n//           function () {\n//             clean()\n//           }.bind(this)\n//         )\n//     } else {\n//       clean()\n//     }\n\n//     this.event(_EVENTS.exitRoom)\n//   }\n\n//   ///////  HELPERS //////////\n\n//   async roomInfo() {\n//     let info = await this.socket.request('getMyRoomInfo')\n//     return info\n//   }\n\n//   static get mediaType() {\n//     return mediaType\n//   }\n\n//   event(evt) {\n//     if (this.eventListeners.has(evt)) {\n//       this.eventListeners.get(evt).forEach((callback) => callback())\n//     }\n//   }\n\n//   on(evt, callback) {\n//     this.eventListeners.get(evt).push(callback)\n//   }\n\n//   //////// GETTERS ////////\n\n//   isOpen() {\n//     return this._isOpen\n//   }\n\n//   static get EVENTS() {\n//     return _EVENTS\n//   }\n\n//   //////// UTILITY ////////\n\n//   copyURL() {\n//     let tmpInput = document.createElement('input')\n//     document.body.appendChild(tmpInput)\n//     tmpInput.value = window.location.href\n//     tmpInput.select()\n//     document.execCommand('copy')\n//     document.body.removeChild(tmpInput)\n//     console.log('URL copied to clipboard 👍')\n//   }\n\n//   showDevices() {\n//     if (!this.isDevicesVisible) {\n//       reveal(devicesList)\n//       this.isDevicesVisible = true\n//     } else {\n//       hide(devicesList)\n//       this.isDevicesVisible = false\n//     }\n//   }\n\n//   handleFS(id) {\n//     let videoPlayer = document.getElementById(id)\n//     videoPlayer.addEventListener('fullscreenchange', (e) => {\n//       if (videoPlayer.controls) return\n//       let fullscreenElement = document.fullscreenElement\n//       if (!fullscreenElement) {\n//         videoPlayer.style.pointerEvents = 'auto'\n//         this.isVideoOnFullScreen = false\n//       }\n//     })\n//     videoPlayer.addEventListener('webkitfullscreenchange', (e) => {\n//       if (videoPlayer.controls) return\n//       let webkitIsFullScreen = document.webkitIsFullScreen\n//       if (!webkitIsFullScreen) {\n//         videoPlayer.style.pointerEvents = 'auto'\n//         this.isVideoOnFullScreen = false\n//       }\n//     })\n//     videoPlayer.addEventListener('click', (e) => {\n//       if (videoPlayer.controls) return\n//       if (!this.isVideoOnFullScreen) {\n//         if (videoPlayer.requestFullscreen) {\n//           videoPlayer.requestFullscreen()\n//         } else if (videoPlayer.webkitRequestFullscreen) {\n//           videoPlayer.webkitRequestFullscreen()\n//         } else if (videoPlayer.msRequestFullscreen) {\n//           videoPlayer.msRequestFullscreen()\n//         }\n//         this.isVideoOnFullScreen = true\n//         videoPlayer.style.pointerEvents = 'none'\n//       } else {\n//         if (document.exitFullscreen) {\n//           document.exitFullscreen()\n//         } else if (document.webkitCancelFullScreen) {\n//           document.webkitCancelFullScreen()\n//         } else if (document.msExitFullscreen) {\n//           document.msExitFullscreen()\n//         }\n//         this.isVideoOnFullScreen = false\n//         videoPlayer.style.pointerEvents = 'auto'\n//       }\n//     })\n//   }\n// }\n","import React, { useState } from 'react';\nimport RoomClient from './RoomClient';\n\nconst App: React.FC = () => {\n  const [roomId, setRoomId] = useState('');\n  const [name, setName] = useState('');\n  const [roomClient, setRoomClient] = useState<RoomClient | null>(null);\n\n  const handleJoin = () => {\n    if (roomId && name) {\n      const client = new RoomClient(roomId, name);\n      setRoomClient(client);\n    }\n  };\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        placeholder=\"Room ID\"\n        value={roomId}\n        onChange={(e) => setRoomId(e.target.value)}\n      />\n      <input\n        type=\"text\"\n        placeholder=\"Your Name\"\n        value={name}\n        onChange={(e) => setName(e.target.value)}\n      />\n      <button onClick={handleJoin}>Join Room</button>\n      {roomClient && <div>Room client initialized</div>}\n    </div>\n  );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n\n\n// if (location.href.substr(0, 5) !== 'https') location.href = 'https' + location.href.substr(4, location.href.length - 4)\n\n// const socket = io()\n\n// let producer = null\n\n// nameInput.value = 'user_' + Math.round(Math.random() * 1000)\n\n// socket.request = function request(type, data = {}) {\n//   return new Promise((resolve, reject) => {\n//     socket.emit(type, data, (data) => {\n//       if (data.error) {\n//         reject(data.error)\n//       } else {\n//         resolve(data)\n//       }\n//     })\n//   })\n// }\n\n// let rc = null\n\n// function joinRoom(name, room_id) {\n//   if (rc && rc.isOpen()) {\n//     console.log('Already connected to a room')\n//   } else {\n//     initEnumerateDevices()\n\n//     rc = new RoomClient(localMedia, remoteVideos, remoteAudios, window.mediasoupClient, socket, room_id, name, roomOpen)\n\n//     addListeners()\n//   }\n// }\n\n// function roomOpen() {\n//   login.className = 'hidden'\n//   reveal(startAudioButton)\n//   hide(stopAudioButton)\n//   reveal(startVideoButton)\n//   hide(stopVideoButton)\n//   reveal(startScreenButton)\n//   hide(stopScreenButton)\n//   reveal(exitButton)\n//   reveal(copyButton)\n//   reveal(devicesButton)\n//   control.className = ''\n//   reveal(videoMedia)\n// }\n\n// function hide(elem) {\n//   elem.className = 'hidden'\n// }\n\n// function reveal(elem) {\n//   elem.className = ''\n// }\n\n// function addListeners() {\n//   rc.on(RoomClient.EVENTS.startScreen, () => {\n//     hide(startScreenButton)\n//     reveal(stopScreenButton)\n//   })\n\n//   rc.on(RoomClient.EVENTS.stopScreen, () => {\n//     hide(stopScreenButton)\n//     reveal(startScreenButton)\n//   })\n\n//   rc.on(RoomClient.EVENTS.stopAudio, () => {\n//     hide(stopAudioButton)\n//     reveal(startAudioButton)\n//   })\n//   rc.on(RoomClient.EVENTS.startAudio, () => {\n//     hide(startAudioButton)\n//     reveal(stopAudioButton)\n//   })\n\n//   rc.on(RoomClient.EVENTS.startVideo, () => {\n//     hide(startVideoButton)\n//     reveal(stopVideoButton)\n//   })\n//   rc.on(RoomClient.EVENTS.stopVideo, () => {\n//     hide(stopVideoButton)\n//     reveal(startVideoButton)\n//   })\n//   rc.on(RoomClient.EVENTS.exitRoom, () => {\n//     hide(control)\n//     hide(devicesList)\n//     hide(videoMedia)\n//     hide(copyButton)\n//     hide(devicesButton)\n//     reveal(login)\n//   })\n// }\n\n// let isEnumerateDevices = false\n\n// function initEnumerateDevices() {\n//   // Many browsers, without the consent of getUserMedia, cannot enumerate the devices.\n//   if (isEnumerateDevices) return\n\n//   const constraints = {\n//     audio: true,\n//     video: true\n//   }\n\n//   navigator.mediaDevices\n//     .getUserMedia(constraints)\n//     .then((stream) => {\n//       enumerateDevices()\n//       stream.getTracks().forEach(function (track) {\n//         track.stop()\n//       })\n//     })\n//     .catch((err) => {\n//       console.error('Access denied for audio/video: ', err)\n//     })\n// }\n\n// function enumerateDevices() {\n//   // Load mediaDevice options\n//   navigator.mediaDevices.enumerateDevices().then((devices) =>\n//     devices.forEach((device) => {\n//       let el = null\n//       if ('audioinput' === device.kind) {\n//         el = audioSelect\n//       } else if ('videoinput' === device.kind) {\n//         el = videoSelect\n//       }\n//       if (!el) return\n\n//       let option = document.createElement('option')\n//       option.value = device.deviceId\n//       option.innerText = device.label\n//       el.appendChild(option)\n//       isEnumerateDevices = true\n//     })\n//   )\n// }\n"],"sourceRoot":""}